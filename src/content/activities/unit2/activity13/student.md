### Autoevaluación  

En esta unidad aprendí sobre la importancia del lenguaje ensamblador y cómo interactúa directamente con la arquitectura del computador. Un aspecto clave fue la manipulación de memoria a través de punteros, lo que me permitió comprender cómo se accede y modifica la información almacenada en direcciones específicas. Por ejemplo, en la actividad donde usamos punteros para modificar el valor de una variable sin acceder directamente a ella, pude ver cómo el uso del operador `*` en C++ se traduce a instrucciones en ensamblador que cargan y almacenan datos en memoria.  

Uno de los conceptos más desafiantes fue la traducción entre código de alto nivel y lenguaje ensamblador. Al principio, me costó entender cómo las estructuras de control como los `for` y `while` se implementaban con saltos condicionales y etiquetas en ensamblador. Otro reto fue interpretar el lenguaje de máquina y deducir su equivalente en ensamblador, especialmente en las actividades de ingeniería inversa.  

Para superar estos desafíos, usé diferentes estrategias. Primero, comparé el código de alto nivel con su equivalente en ensamblador línea por línea para identificar patrones. También utilicé el simulador para ejecutar el código paso a paso y observar cómo cambiaban los registros y la memoria. Además, hice anotaciones en mi bitácora para visualizar cómo se transformaban las estructuras de control y los accesos a memoria.  

La estrategia más efectiva fue la simulación. Poder ver cómo se ejecutaban las instrucciones y modificar valores manualmente me ayudó a entender mejor la relación entre el código y el hardware. También fue útil descomponer los problemas en pasos más pequeños y traducir fragmentos de código en lugar de intentar hacerlo todo de una vez.  

En general, esta unidad me dio una comprensión más profunda sobre cómo funcionan los programas a nivel de hardware y me ayudó a desarrollar una mentalidad más estructurada para optimizar código y depurar errores.
