Antes de esta unidad, había escuchado sobre los patrones Observer, Factory y State, pero solo de forma superficial. Sabía que eran herramientas para estructurar mejor el código, pero no entendía cuándo debía usar cada uno ni qué problema resolvían exactamente. Ahora, después de haberlos implementado directamente en mi proyecto, siento que los comprendo mucho mejor, tanto a nivel técnico como conceptual. Sé identificar cuándo conviene usar Observer para desacoplar eventos, cuándo una Factory ayuda a mantener el código limpio y escalable, y cómo el patrón State me permite gestionar comportamientos que cambian en el tiempo. Lo que antes me parecía abstracto, hoy lo veo como algo práctico que mejora mi forma de programar.

De todos los conceptos de esta unidad, el patrón Factory fue el que me resultó más fácil de entender y aplicar. Su lógica es directa: delegar la creación de objetos a una clase específica. Eso me permitió organizar mejor las distintas visualizaciones generativas del proyecto sin tener que modificar múltiples partes del código cuando quería probar nuevos tipos. También me fue fácil trabajar con herencia y polimorfismo, porque ya había tenido experiencias anteriores en actividades creativas, y este patrón encajó muy bien con esa forma de trabajo modular y flexible.

Lo más difícil fue implementar correctamente el patrón Observer. Me costó bastante entender cómo separar las responsabilidades para que los distintos módulos reaccionaran a eventos sin estar directamente acoplados entre sí. Al principio tenía todo el código de entrada y reacción en una misma clase, lo que me generaba problemas al intentar escalar. Para resolverlo, revisé los ejemplos del curso varias veces, hice pequeñas pruebas aisladas con funciones de notificación simuladas y solo después integré la lógica completa con los datos del micro\:bit y el móvil. Una vez entendí el patrón, noté que me ayudaba mucho a organizar el flujo de eventos en el sistema de forma clara y mantenible.

Si pudiera repetir esta unidad, dedicaría más tiempo al diseño inicial del proyecto, planificando con mayor claridad cómo se relacionan entre sí las clases y qué responsabilidades tiene cada una. Creo que habría sido útil bocetar una arquitectura con los patrones desde el comienzo, en lugar de descubrir dónde aplicarlos a medida que programaba. También intentaría consultar recursos externos, como foros o videos, para ver más casos de uso reales y compararlos con el mío. Así habría evitado algunas reestructuraciones que me hicieron perder tiempo durante la implementación.

Estoy convencido de que estos conocimientos me serán muy útiles en el futuro, tanto en otros cursos como en proyectos personales e incluso en el ámbito profesional. Muchas aplicaciones reales requieren que los objetos reaccionen a eventos, cambien de comportamiento o se creen dinámicamente según las condiciones. Saber implementar estos patrones me da herramientas para enfrentar ese tipo de retos con soluciones robustas. Por ejemplo, en un videojuego, un menú podría ser gestionado por distintos estados, o los enemigos creados con una factory dependiendo del nivel, o las interacciones del jugador notificadas mediante Observer a distintos sistemas.

Finalmente, creo que incluso para artistas o creativos que programan ocasionalmente, entender estos patrones puede ser de gran ayuda. No se trata solo de escribir código que funcione, sino de escribir código que se pueda mantener, modificar y ampliar con facilidad. En arte generativo, por ejemplo, donde los comportamientos visuales pueden cambiar con el tiempo o reaccionar a sensores, el patrón State o Observer permite que el código crezca sin desordenarse. Además, una Factory puede facilitar la exploración creativa de variaciones visuales sin necesidad de modificar muchas líneas. Estos patrones, aunque provienen del diseño de software tradicional, tienen un enorme potencial para hacer que los proyectos creativos sean más sólidos y sostenibles.
